#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#include "assembly.h"

extern table GlobalIDs;

void Assembly::PutString(char *s)
{
	int len = strlen(s);
	int i;
	char *p;

	if (len > BUF_LEN)
	{
		fwrite(s, 1, len, ASMFile);
		return;
	}

	if (len > BUF_LEN - BufferSize)
	{
		Flush();
	}

	p = OutBuffer + BufferSize;
	for (i = 0; i < len; ++i)
	{
		p[i] = s[i];
	}
	BufferSize += len;
}

void Assembly::Flush(void)
{
	if (BufferSize != 0)
	{
		fwrite(OutBuffer, 1, BufferSize, ASMFile);
	}
	BufferSize = 0;
}

void Assembly::EmitTranslationUnit()
{
	sprintf(ASMFileName, "%s", "assembly.asm");

	if (ASMFileName) {
		ASMFile = fopen(ASMFileName, "w");
	}
	else {
		//ASMFile = CreateOutput(Input.filename, ExtName);
	}

	BeginProgram();
	Segment(DATA);
	EmitGlobals();
	Segment(CODE);
	EmitFunctions();
	EndProgram();

	fclose(ASMFile);
}

void Assembly::BeginProgram(void)
{

	//for (i = EAX; i <= EDI; ++i)
	//{
		// Initialize register symbols to
		// make sure that no register contains data from variables.
		//if (X86Regs[i] != NULL)
		//{
		//	X86Regs[i]->link = NULL;
		//}
	//}

	PutString("# Code auto-generated by zhin\n\n");
}

void Assembly::Segment(int seg)
{
	if (seg == DATA)
	{
		PutString(".data\n\n");
	}
	else if (seg == CODE)
	{
		PutString(".text\n\n");
	}
}

void Assembly::EmitGlobals(void)
{
	vector<Symbol>::iterator p = GlobalIDs.buckets.begin();

	for (; p != GlobalIDs.buckets.end(); p++) {
		if ((*p)->kind == SK_Variable) {
			DefineGlobal(*p);
			PutString("\n");
		}
	}
}

void Assembly::EmitFunctions(void)
{
	vector<Symbol>::iterator p = GlobalIDs.buckets.begin();

	for (; p != GlobalIDs.buckets.end(); p++) {
		if ((*p)->kind == SK_Function) {
			EmitFunction((FunctionSymbol)*p);
		}
	}
}

void Assembly::EndProgram(void)
{
	Flush();
}

void Assembly::EmitFunction(FunctionSymbol p)
{
	//Export((Symbol)p);  mips不需要
	DefineLabel((Symbol)p);
}

void Assembly::DefineGlobal(Symbol p)
{
	char tmp[1024];

	//Export(p);  mips下不需要

	sprintf(tmp, "%s:	.word	%d\t", p->name.c_str(),p->ref);
	PutString(tmp);

}

void Assembly::DefineLabel(Symbol p)
{
	char tmp[1024];
	vector<Symbol>::iterator buckets_it = GlobalIDs.buckets.begin();
	BBlock entryBB = ((FunctionSymbol)(*buckets_it))->entryBB;


	sprintf(tmp, "%s:\n", p->name.c_str());

	PutString(tmp);
}

void Assembly::Export(Symbol p)
{
	char tmp[1024];

	sprintf(tmp, ".globl\t%s\n\n", p->name.c_str());
	PutString(tmp);
}

void Assembly::output()
{
	BufferSize = 0;

	EmitTranslationUnit();
}

